<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MWS Analysis Report</title>

    <!-- OpenLayers CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.4.0/ol.css">

    <!-- Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

    <!-- OpenLayers JS -->
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.4.0/dist/ol.js"></script>

    <!-- OpenLayers-ext JS -->
    <script src="https://cdn.jsdelivr.net/npm/ol-ext@4.0.27/dist/ol-ext.min.js"></script>

    <!-- OpenLayers-ext CSS -->
    <link href="https://cdn.jsdelivr.net/npm/ol-ext@4.0.27/dist/ol-ext.min.css" rel="stylesheet">

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            color: #333;
        }
        .container {
            width: 90%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background-color: #2c3e50;
            color: white;
            padding: 20px 0;
            text-align: center;
        }
        h1, h2, h3 {
            margin-top: 0;
        }
        .section {
            margin-bottom: 40px;
            page-break-inside: avoid;
        }
        .map-group{
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }
        .map {
            height: 400px;
            width: 100%;
            margin: 20px 0;
            border: 1px solid #ddd;
        }
        .chart-container {
            position: relative;
            height: 300px;
            width: 70vw;
            margin: 20px 0 10px 0;
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 10px 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 2px;
        }
        footer {
            margin-top: 40px;
            border-top: 1px solid #ddd;
            padding-top: 20px;
            text-align: center;
            color: #7f8c8d;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .legend-note {
            color: #6c757d;       /* gray */
            text-align: center;
            font-size: 0.9rem;
            font-style: italic;
            margin: 6px 0 0;      /* tight spacing under legend */
        }

        /* Print Button Styles */
        .print-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #27ae60;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            transition: background-color 0.3s;
        }
        
        .print-button:hover {
            background-color: #2ecc71;
        }
        
        .print-button svg {
            margin-right: 5px;
        }
        
        .doc-button {
            position: absolute;
            top: 20px;
            right: 140px; /* shift left of the PDF button */
            background-color: #0078d4;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            transition: background-color 0.3s;
        }

        .doc-button:hover { background-color: #005a9e; }
        
        @media print { 
            .doc-button { display: none; }   
            .legend-note {
                margin-top: 3em;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            } 
        }

        /* Hide print button when printing */
        @media print {
            .print-button {
                display: none;
            }
        }

       /* Print-specific styles */
       @media print {
        html, body {
          width: 100%;
          height: 100%;
          margin: 0;
          padding: 0;
        }
        #map {
          width: 100vw;
          height: 100vh;
        }

        .container {
            width: 100vw;
            max-width: none;
            padding: 0;
        }

        header {
            background-color: #2c3e50 !important;
            color: white !important;
            padding: 15px 0;
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }

        .chart-container {
            height: 250px !important;
            width: 80vw !important;
            page-break-inside: avoid;
            break-inside: avoid;
            margin-top: 1em;
            margin-bottom: 4em;
        }

        .legend-color {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
            background-clip: content-box !important;
        }

        /* Ensure charts render properly */
        canvas {
            height: auto !important;
            max-width: auto !important;
        }


      }
      
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Micro-Watershed Data Analysis Report</h1>
            <p>Spatial and Temporal Analysis of Key Metrics</p>
            <button class="print-button" onclick="printReport()">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                     stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="6 9 6 2 18 2 18 9"></polyline>
                    <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path>
                    <rect x="6" y="14" width="12" height="8"></rect>
                </svg>
                Save as PDF
            </button>
        </div>


    </header>

    <div class="container">
        <section class="section">
            <h2>Overview of Tehsil characteristics</h2>
            <p>{{block_osm}}</p>
        </section>

        <section class="section">
            <h2>Landscape Overview</h2>
            <p>{{mws_osm}}</p>

            <div id="mainMap" class="map"></div>
        </section>

        <section class="section">
            <h3>Terrain Comparison</h3>
            <p>{{terrain_mws}}</p>

            <div class="map-group">
                <div id="terrainMap" class="map"></div>
                <div id="compMap1" class="map"></div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #313695;"></div>
                    <span>V-shape river valleys, Deep narrow canyons</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4575b4;"></div>
                    <span>Lateral midslope incised drainages, Local valleys in plains</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #a50026;"></div>
                    <span>Upland incised drainages, Stream headwaters</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e0f3f8;"></div>
                    <span>U-shape valleys</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #fffc00;"></div>
                    <span>Broad Flat Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #feb24c;"></div>
                    <span>Broad open slopes</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f46d43;"></div>
                    <span>Mesa tops</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #d73027;"></div>
                    <span>Upper Slopes</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #91bfdb;"></div>
                    <span>Local ridge/hilltops within broad valleys</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #800000;"></div>
                    <span>Lateral midslope drainage divides, Local ridges in plains</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4d0000;"></div>
                    <span>Mountain tops, high ridges</span>
                </div>
            </div>

            <p class="legend-note">
                Note: We used NASAâ€™s SRTM Digital Elevation Model at 30m resolution to generate landform classification.
            </p>
        </section>

        <section class="section">
            <h4>Terrain Comparison for Block and MWS</h4>
            <p>{{terrain_comp}}</p>

            <p>The chart illustrates the distribution of different terrain types across the total block. It highlights the percentage of each terrain type to the total block while also showcasing the specific percentage of a single MWS to the overall percentage.</p>

            <div class="chart-container">
                <canvas id="barChart"></canvas>
            </div>
            <br/>

        </section>

        <section class="section">
            <h4>Land use on slopes and plains</h4>
            <p>{{terrain_land_use}}</p>

            <div class="chart-container" id="slopeChartContainer">
                <canvas id="barChart-terrain-lulc-slope"></canvas>
            </div>

            <div class="chart-container" id="plainChartContainer">
                <canvas id="barChart-terrain-lulc-plain"></canvas>
            </div>

            <p class="legend-note">Note: Data remotely sensed from satellites including LandSat-7, LandSat-8,
                Sentinel-2, Sentinel-1, MODIS and Dynamic World.</p>
        </section>

        {% if land_degrad %}
            <section class="section">
                <h4>Degradation of land</h4>
                <p>{{land_degrad}}</p>

                <div class="map-group">
                    <div id="degradLandMap" class="map"></div>
                    <div id="compMap3" class="map"></div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #eee05d;"></div>
                        <span>Crops - Crops</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff0000;"></div>
                        <span>Crops - Built Up</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #a9a9a9;"></div>
                        <span>Crops - Barren</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #eaa4f0;"></div>
                        <span>Crops - Shrubs and Scrubs</span>
                    </div>
                </div>

                <p class="legend-note">Note: The degradation in cropping is computed using the IndiaSAT Land Use Land
                    Cover outputs. Transitions from farmland to barren land, shrubs, human settlements (built-up) are
                    computed</p>
            </section>
        {% endif %}

        {% if tree_degrad %}
            <section class="section">
                <h4>Reduction in tree cover</h4>
                <p>{{tree_degrad}}</p>

                <div class="map-group">
                    <div id="treeReduceMap" class="map"></div>
                    <div id="compMap4" class="map"></div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #73bb53;"></div>
                        <span>Trees - Trees</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff0000;"></div>
                        <span>Trees - Built Up</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #eee05d;"></div>
                        <span>Trees - Crops</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #a9a9a9;"></div>
                        <span>Trees - Barren</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #eaa4f0;"></div>
                        <span>Trees - Shrubs and Scrubs</span>
                    </div>
                </div>
                <p class="legend-note">Note: The reduction in tree cover is computed using the IndiaSAT Land Use Land
                    Cover outputs. Transitions from tree cover to barren land, shrubs, human settlements (built-up) or
                    farmland are computed.</p>

                <p>{{restore_desc}}</p>
            </section>
        {% endif %}

        {% if urbanization %}
            <section class="section">
                <h4>Urbanization</h4>
                <p>{{urbanization}}</p>

                <div class="map-group">
                    <div id="urbanMap" class="map"></div>
                    <div id="compMap5" class="map"></div>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff0000;"></div>
                        <span>Built Up - Built Up</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #1ca3ec;"></div>
                        <span>Water - Built Up</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #73bb53;"></div>
                        <span>Tree/Crops - Built Up</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #a9a9a9;"></div>
                        <span>Barren/Shrubs and Scrubs - Built Up</span>
                    </div>
                </div>
                <p class="legend-note">Note: Urbanization is computed using the IndiaSAT Land Use Land Cover outputs.
                    Transitions from tree cover, farmland, and barren land to human settlements (built-up) are
                    computed.</p>

            </section>
        {% endif %}

        <section class="section">
            <h4>Cropping Intensity</h4>
            <p>{{inten_desc1}}</p>
            <p>{{inten_desc2}}</p>

            <div class="chart-container">
                <canvas id="barChart-intensity"></canvas>
            </div>

            <p class="legend-note">Note: We use annual land use land cover (LULC), to identify areas under single
                cropping, double cropping and triple cropping using pixels which are classified as single kharif, single
                non-kharif, double and triple classes of LULC classifier to determine cropping intensity.</p>
        </section>

        <section class="section">
            <h4>Average percentage of double cropped area</h4>
            <p>{{double_crop_des}}</p>
            
            <div class="map-group">
                <div id="lulcMap" class="map"></div>
                <div id="compMap2" class="map"></div>
            </div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #A9A9A9;"></div>
                    <span>Barren Lands</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #c6e46d;"></div>
                    <span>Single Kharif</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #eee05d;"></div>
                    <span>Single Non-Kharif</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f9b249;"></div>
                    <span>Double Cropping</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #fb5139;"></div>
                    <span>Triple Cropping</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4c4ef5;"></div>
                    <span>Shrubs and Scrubs</span>
                </div>
            </div>
            <p class="legend-note">
                Note: The Resolution of LULC image is 10 meter.
            </p>
        </section>

        <section class="section">
            <h4>Surface water bodies</h4>
            <p>{{swb_desc}}</p>

            <p>{{trend_desc}}</p>

            <p>{{final_desc}}</p>

            <div class="chart-container">
                <canvas id="barChart-swb"></canvas>
            </div>

            <div id="swbMap" class="map"></div>

            <p class="legend-note">
                Note: We use Sentinel-1 (SAR data) VV band for water pixel detection in Kharif season and Dynamic World
                to detect water pixels in Rabi and Zaid seasons.
            </p>

            <p>{{swb_season_desc}}</p>
        </section>

        <section class="section">
            <h4>Water Balance</h4>
            <p>A water balance study of the microwatershed indicates whether it is helping conserve water or deplete
                water from the underlying aquifer. Incoming water into a microwatershed is predominantly through
                rainfall. Some of this is lost as runoff while the rest percolates into the ground. Crops pull some of
                this groundwater, and borewells for irrigation may pull groundwater from deeper aquifers too. A positive
                water balance indicates that less of the incoming water is lost, while a negative water balance
                indicates that the microwatershed takes away more water.</p>

            <p>{{wb_desc}}</p>
            <p>{{good_rainfall}}</p>
            <p>{{bad_rainfall}}</p>

            <p>Do note that currently we only consider the vertical flux in the microwatershed. We are working on how to
                model incoming runoff into the microwatershed, as well as sub-surface flow from adjacent areas.</p>
            <div class="chart-container">
                <canvas id="lineChart-water"></canvas>
            </div>
            <p class="legend-note">
                Note: Precipitation data is calculated from the Global Satellite Mapping of Precipitation (GSMaP)
                dataset available on Google Earth Engineâ€™s data catalogue. GSMaP provides a global precipitation in
                mm/hr at spatial resolution of approximately 11km.
                Runoff is calculated using precipitation data (GSMaP at 11 km resolution), soil type (HYSOGs250m
                dataset), slope (NASA SRTM DEM dataset at 30 m resolution) and land cover (Dynamic World dataset at 10m
                resolution). For further information on the computation, refer our <a
                    href="https://drive.google.com/file/d/1ZxovdpPThkN09cB1TcUYSE2BImI7M3k_/view" target="_blank">technical
                manual</a>.
            </p>
            <div class="chart-container">
                <canvas id="lineChart-evp"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="lineChart-gw"></canvas>
            </div>
            <p class="legend-note">
                Note: Computed by subtracting outgoing fluxes (runoff and evaporatranspiration) from incoming water
                (precipitation).
            </p>
        </section>

        {% if soge_desc %}
        <section class="section">
            <h4>State of groundwater extraction</h4>

            <p>The state of groundwater extraction refers to the current level or intensity at which groundwater is
                being withdrawn from aquifers compared to its natural replenishment rate. Based on this ratio, agencies
                like the Central Ground Water Board (CGWB) in India classify areas into categories indicating the extent
                of extraction.</p>

            <p>{{soge_desc}}</p>

            <div id="sogeMap" class="map"></div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ffffff;"></div>
                    <span>Safe</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e0f3f8;"></div>
                    <span>Semi - Critical</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4575b4;"></div>
                    <span>Critical</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #313695;"></div>
                    <span>Over - Exploited</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #a9a9a9;"></div>
                    <span>Not Assessed</span>
                </div>
            </div>

        </section>
        {% endif %}

        <section class="section">
            <h4>Drought Analysis</h4>
            <p>{{drought_desc}}</p>

            <p>A Drought year is declared if the total number of weeks under severe intensity drought and moderate
                intensity drought exceed 5, which means that the rainfall deficit was more than 25% for more than 5
                weeks during the monsoon of that year.</p>

            <p>The occurrence of dry spell is defined across four consecutive weeks with each week of these
                four weeks incurring a rainfall deviation of less than 50%. Prolonged dry spells can lead to
                significant reduction in crop sown area.</p>

            <!-- <div class="chart-container">
                <canvas id="Chart-drought"></canvas>
            </div> -->

            <div class="chart-container">
                <canvas id="Chart-drought-weeks"></canvas>
            </div>

            <p class="legend-note">Note: Drought is defined as per the Government of India's Drought Manual and
                considered moderate or severe if the number of weeks of drought is five or more. Drought weeks are
                identified based on whether meteorological drought occurred in that week (i.e. the rains were less than
                usual in that week as compared to previous years, possibly intensified by dry spells defined as
                consecutive weeks of low rainfall) and/or agricultural drought occurred in that week (i.e. cropped area
                or crop health were lower than usual in that week as compared to previous years). Severe drought weeks
                are those when meteorological and agricultural drought are both coincident.</p>
        </section>

        <section class="section">
            <div class="village-section">
            <h2>Village Profile</h2>
            <p>There are <span id="vilage-count"></span> villages intersecting with this microwatershed:</p>
            <ul id="village-names"></ul>

            <h4>MGNREGA works</h4>
            <p>MGNREGA works of soil and water conservation, such as trench cum bunds, irrigation structures like farm ponds, and plantation works, are essential to enhance agricultural productivity and build climate resilience against droughts. In this micro-watershed, the allocation has seen the following uptake</p>

            <table id="village-table">
                <thead>
                    <tr>
                        <th>Village Name</th>
                        <th>Total Population</th>
                        <th>Total SC % Population</th>
                        <th>Total ST % Population</th>
                        <th>Soil and Water Conservation</th>
                        <th>Land Restoration</th>
                        <th>Plantation</th>
                        <th>Irrigation on Farm</th>
                        <th>Irrigation Site Livelihoods</th>
                        <th>Off-farm Livelihoods</th>
                        <th>Community Assets</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            </div>
        </section>

    </div>

    <footer>
        <div class="container">
            <p>Report generated on <span id="report-date"></span> | CoRE Stack Team</p>
            <p>Refer to our <a href="https://drive.google.com/file/d/1ZxovdpPThkN09cB1TcUYSE2BImI7M3k_/view"
                               target="_blank">technical manual</a> for more details on how data was collected and
                processed.</p>
            <p>
                Do note that while the underlying datasets have been validated against groundâ€‘truth in some locations,
                we need your feedback if the outputs shown here are in agreement with your observations about this area.
                Please do share your feedback with
                <a href="mailto:contact@core-stack.org">contact@core-stack.org</a>.
            </p>
        </div>
    </footer>

    <script>

        const baseLayer = new ol.layer.Tile({
            source: new ol.source.XYZ({
                url: `https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}`,
                maxZoom: 30,
                transition: 500,
            }),
            preload: 4,
        });

        const view = new ol.View({
            center: [78.9, 23.6],
            zoom: 10,
            projection: "EPSG:4326",
            constrainResolution: true,
            smoothExtentConstraint: true,
            smoothResolutionConstraint: true,
        });

        const mainMap = new ol.Map({
            target: 'mainMap',
            layers: [baseLayer],
            view: view,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        });

        const wmsLayer = new ol.layer.Image({
            source : new ol.source.ImageWMS({
                url : 'https://geoserver.core-stack.org:8443/geoserver/wms',
                params : {
                    'LAYERS': "terrain:{{district}}_{{block}}_terrain_raster",
                    'STYLES' : 'Terrain_Style_11_Classes'
                },
                ratio : 1,
                serverType: 'geoserver',
            }),
            visible : true,
            name : 'terrain_raster'
        })

        const degradRaster = new ol.layer.Image({
            source : new ol.source.ImageWMS({
                url : 'https://geoserver.core-stack.org:8443/geoserver/wms',
                params : {
                    'LAYERS': "change_detection:change_{{district}}_{{block}}_Degradation",
                    'STYLES' : "degradation"
                },
                ratio : 1,
                serverType: 'geoserver',
            }),
            visible : true,
            name : 'degrad_raster'
        })

        const lulcRaster = new ol.layer.Image({
            source : new ol.source.ImageWMS({
                url : 'https://geoserver.core-stack.org:8443/geoserver/wms',
                params : {
                    'LAYERS': "LULC_level_3:LULC_22_23_{{block}}_level_3",
                    'STYLES' : "lulc_level_3_style"
                },
                ratio : 1,
                serverType: 'geoserver',
            }),
            visible : true,
            name : 'lulc_raster'
        })

        const waterRaster = new ol.layer.Image({
            source : new ol.source.ImageWMS({
                url : 'https://geoserver.core-stack.org:8443/geoserver/wms',
                params : {
                    'LAYERS': "LULC_level_3:LULC_22_23_{{block}}_level_3",
                    'STYLES' : "lulc_water_pixels"
                },
                ratio : 1,
                serverType: 'geoserver',
            }),
            visible : true,
            name : 'water_raster'
        })

        const urbanRaster = new ol.layer.Image({
            source : new ol.source.ImageWMS({
                url : 'https://geoserver.core-stack.org:8443/geoserver/wms',
                params : {
                    'LAYERS': "change_detection:change_{{district}}_{{block}}_Urbanization",
                    'STYLES' : "urbanization"
                },
                ratio : 1,
                serverType: 'geoserver',
            }),
            visible : true,
            name : 'tree_raster'
        })

        const treeReduceRaster = new ol.layer.Image({
            source : new ol.source.ImageWMS({
                url : 'https://geoserver.core-stack.org:8443/geoserver/wms',
                params : {
                    'LAYERS': "change_detection:change_{{district}}_{{block}}_Deforestation",
                    'STYLES' : "deforestation"
                },
                ratio : 1,
                serverType: 'geoserver',
            }),
            visible : true,
            name : 'tree_raster'
        })

        const tempView1 = new ol.View({
            center: [78.9, 23.6],
            zoom: 10,
            projection: "EPSG:4326",
            constrainResolution: true,
            smoothExtentConstraint: true,
            smoothResolutionConstraint: true,
        })

        const TerrainMap = new ol.Map({
            target: 'terrainMap',
            layers: [wmsLayer],
            view: tempView1,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        const ComparisonMap1 = new ol.Map({
            target: 'compMap1',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: `https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}`,
                        maxZoom: 30,
                        transition: 500,
                    }),
                    preload: 4,
                })
            ],
            view: tempView1,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        const tempView2 = new ol.View({
                center: [78.9, 23.6],
                zoom: 10,
                projection: "EPSG:4326",
                constrainResolution: true,
                smoothExtentConstraint: true,
                smoothResolutionConstraint: true,
            })

        const ComparisonMap2 = new ol.Map({
            target: 'compMap2',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: `https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}`,
                        maxZoom: 30,
                        transition: 500,
                    }),
                    preload: 4,
                })
            ],
            view: tempView2,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        const tempView3 = new ol.View({
            center: [78.9, 23.6],
            zoom: 10,
            projection: "EPSG:4326",
            constrainResolution: true,
            smoothExtentConstraint: true,
            smoothResolutionConstraint: true,
        })

        const ComparisonMap3 = new ol.Map({
            target: 'compMap3',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: `https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}`,
                        maxZoom: 30,
                        transition: 500,
                    }),
                    preload: 4,
                })
            ],
            view: tempView3,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        const tempView4 = new ol.View({
            center: [78.9, 23.6],
            zoom: 10,
            projection: "EPSG:4326",
            constrainResolution: true,
            smoothExtentConstraint: true,
            smoothResolutionConstraint: true,
        })

        const ComparisonMap4 = new ol.Map({
            target: 'compMap4',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: `https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}`,
                        maxZoom: 30,
                        transition: 500,
                    }),
                    preload: 4,
                })
            ],
            view: tempView4,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        const tempView5 = new ol.View({
            center: [78.9, 23.6],
            zoom: 10,
            projection: "EPSG:4326",
            constrainResolution: true,
            smoothExtentConstraint: true,
            smoothResolutionConstraint: true,
        })

        const ComparisonMap5 = new ol.Map({
            target: 'compMap5',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: `https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}`,
                        maxZoom: 30,
                        transition: 500,
                    }),
                    preload: 4,
                })
            ],
            view: tempView5,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        const lulcMap = new ol.Map({
            target: 'lulcMap',
            layers: [lulcRaster],
            view: tempView2,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        const DegradMap = new ol.Map({
            target: 'degradLandMap',
            layers: [degradRaster],
            view: tempView3,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })
        
        const treeReduceMap = new ol.Map({
            target: 'treeReduceMap',
            layers: [treeReduceRaster],
            view: tempView4,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        const swbMap = new ol.Map({
            target: 'swbMap',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: `https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}`,
                        maxZoom: 30,
                        transition: 500,
                    }),
                    preload: 4,
                })
            ],
            view: new ol.View({
                center: [78.9, 23.6],
                zoom: 10,
                projection: "EPSG:4326",
                constrainResolution: true,
                smoothExtentConstraint: true,
                smoothResolutionConstraint: true,
            }),
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        const sogeMap = new ol.Map({
            target: 'sogeMap',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: `https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}`,
                        maxZoom: 30,
                        transition: 500,
                    }),
                    preload: 4,
                })
            ],
            view: new ol.View({
                center: [78.9, 23.6],
                zoom: 10,
                projection: "EPSG:4326",
                constrainResolution: true,
                smoothExtentConstraint: true,
                smoothResolutionConstraint: true,
            }),
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        const urbanMap = new ol.Map({
            target: 'urbanMap',
            layers: [urbanRaster],
            view: tempView5,
            interactions: new ol.Collection([
                new ol.interaction.DragPan(),
                new ol.interaction.KeyboardPan(),
                new ol.interaction.KeyboardZoom(),
            ])
        })

        fetch("https://geoserver.core-stack.org:8443/geoserver/mws_layers/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=mws_layers:deltaG_well_depth_{{district}}_{{block}}&outputFormat=application/json")
        .then(response => response.json())
        .then(data => {
            const vectorSource = new ol.source.Vector({
                features: new ol.format.GeoJSON().readFeatures(data),
            });

            const styleFunction = feature => {
                const uid = feature.get('uid');
                let strokeColor = 'skyblue'; // Default stroke color
                let fillColor = 'rgba(135, 206, 235, 0.4)'; // Default fill color with 0.4 opacity

                if (uid === '{{mws_id}}') {
                    strokeColor = 'yellow';
                    fillColor = 'rgba(255, 255, 0, 0.4)';
                }

                return new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: strokeColor,
                        width: 2,
                    }),
                    fill: new ol.style.Fill({
                        color: fillColor,
                    }),
                });
            };

            const vectorLayer = new ol.layer.Vector({
                source: vectorSource,
                style: styleFunction,
            });

            mainMap.addLayer(vectorLayer);

            const arr = vectorSource.getExtent();
            const mapcenter = [(arr[0] + arr[2]) / 2, (arr[1] + arr[3]) / 2];
            mainMap.getView().setCenter(mapcenter);
        })
        .catch(error => console.error('Error fetching GeoJSON:', error));

        // Fetch GeoJSON data and extract a feature by UID
        const fetchFeatureByUid = async(uid, wmsLayer1, degradRaster1, lulcRaster1, treeReduceRaster1, urbanRaster1, waterRaster1) => {
            await fetch("https://geoserver.core-stack.org:8443/geoserver/mws_layers/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=mws_layers:deltaG_well_depth_{{district}}_{{block}}&outputFormat=application/json")
                .then(response => response.json())
                .then(data => {
                    const features = new ol.format.GeoJSON().readFeatures(data);

                    const feature = features.find(f => f.get('uid') === uid);
                    
                    const vectorSource = new ol.source.Vector({
                        features: [feature],
                    });

                    if (feature) {
                        var crop = new ol.filter.Crop({
                            feature : feature,
                            wrapX: true,
                            inner: false
                        })
                        wmsLayer1.addFilter(crop);
                        degradRaster1.addFilter(crop);
                        lulcRaster1.addFilter(crop);
                        treeReduceRaster1.addFilter(crop);
                        urbanRaster1.addFilter(crop);
                        //waterRaster1.addFilter(crop);
                    }

                    const styleFunctionComp = feature => {
                        strokeColor = 'yellow';
                        fillColor = 'rgba(255, 255, 0, 0.1)';
                        return new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: strokeColor,
                                width: 2,
                            }),
                            fill: new ol.style.Fill({
                                color: fillColor,
                            }),
                        });
                    };

                    const vectorLayerComp = new ol.layer.Vector({
                        source: vectorSource,
                        style: styleFunctionComp,
                    });        

                    ComparisonMap1.addLayer(vectorLayerComp)
                    ComparisonMap2.addLayer(vectorLayerComp)
                    ComparisonMap3.addLayer(vectorLayerComp)
                    ComparisonMap4.addLayer(vectorLayerComp)
                    ComparisonMap5.addLayer(vectorLayerComp)
                    swbMap.addLayer(vectorLayerComp)

                    const arr = vectorSource.getExtent();
                    const mapcenter = [(arr[0] + arr[2]) / 2, (arr[1] + arr[3]) / 2];

                    TerrainMap.getView().setCenter(mapcenter);
                    TerrainMap.getView().setZoom(13);

                    DegradMap.getView().setCenter(mapcenter);
                    DegradMap.getView().setZoom(13);

                    lulcMap.getView().setCenter(mapcenter);
                    lulcMap.getView().setZoom(13);

                    treeReduceMap.getView().setCenter(mapcenter);
                    treeReduceMap.getView().setZoom(13);

                    ComparisonMap1.getView().setCenter(mapcenter);
                    ComparisonMap1.getView().setZoom(13);

                    ComparisonMap2.getView().setCenter(mapcenter);
                    ComparisonMap2.getView().setZoom(13);

                    ComparisonMap3.getView().setCenter(mapcenter);
                    ComparisonMap3.getView().setZoom(13);

                    ComparisonMap4.getView().setCenter(mapcenter);
                    ComparisonMap4.getView().setZoom(13);
                    
                    ComparisonMap5.getView().setCenter(mapcenter);
                    ComparisonMap5.getView().setZoom(13);

                    urbanMap.getView().setCenter(mapcenter);
                    urbanMap.getView().setZoom(13);

                    swbMap.getView().setCenter(mapcenter);
                    swbMap.getView().setZoom(13);

                    sogeMap.getView().setCenter(mapcenter);
                    sogeMap.getView().setZoom(13);
                })
                .catch(error => console.error('Error fetching GeoJSON:', error));
        };

        fetch("https://geoserver.core-stack.org:8443/geoserver/swb/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=swb:surface_waterbodies_{{district}}_{{block}}&outputFormat=application/json")
        .then(response => response.json())
        .then(data => {
            const vectorSource = new ol.source.Vector({
                features: new ol.format.GeoJSON().readFeatures(data),
            });

            const vectorLayer = new ol.layer.Vector({
                source: vectorSource,
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: 'rgb(0, 150, 255)',
                        width: 2,
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(137, 207, 240, 0.4)',
                    }),
                })
            });

            swbMap.addLayer(vectorLayer);
            swbMap.addLayer(waterRaster);
        })
        .catch(error => console.error('Error fetching GeoJSON:', error));

        fetch("https://geoserver.core-stack.org:8443/geoserver/soge/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=soge:soge_vector_{{district}}_{{block}}&outputFormat=application/json")
        .then(response => response.json())
        .then(data => {
            const vectorSource = new ol.source.Vector({
                features: new ol.format.GeoJSON().readFeatures(data),
            });

            const styleFunction = feature => {
                const uid = feature.get('uid');
                const type = feature.get('class');
                let strokeColor = 'rgba(51, 51, 51, 0.0)'; // Default stroke color
                let fillColor = 'rgba(135, 206, 235, 0.0)'; // Default fill color with 0.4 opacity

                if (uid === '{{mws_id}}') {
                    if (type === "Safe") {
                        strokeColor = "rgba(51, 51, 51, 1)";
                        fillColor = "rgba(255, 255, 255, 0.4)";
                    } else if (type === "Semi-critical") {
                        strokeColor = "rgba(51, 51, 51, 1)";
                        fillColor = "rgba(224, 243, 248, 0.4)";
                    } else if (type === "Critical") {
                        strokeColor = "rgba(51, 51, 51, 1)";
                        fillColor = "rgba(69, 117, 180, 0.4)";
                    } else if (type === "Not Assessed") {
                        strokeColor = "rgba(51, 51, 51, 1)";
                        fillColor = "rgba(169, 169, 169, 0.4)";
                    } else {
                        strokeColor = "rgba(51, 51, 51, 1)";
                        fillColor = "rgba(49, 54, 149, 0.4)";
                    }
                }

                return new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: strokeColor,
                        width: 2,
                    }),
                    fill: new ol.style.Fill({
                        color: fillColor,
                    }),
                });
            };

            const vectorLayer = new ol.layer.Vector({
                source: vectorSource,
                style: styleFunction,
            });


            sogeMap.addLayer(vectorLayer);
        })
        .catch(error => console.error('Error fetching GeoJSON:', error));

        // Extract Feature
        fetchFeatureByUid('{{mws_id}}', wmsLayer, degradRaster, lulcRaster, treeReduceRaster, urbanRaster, waterRaster);

        // Terrain Bar Chart
        const mwsTerrain = JSON.parse('{{mws_areas|safe}}')
        const blockTerrain = JSON.parse('{{block_areas|safe}}')
        const barChart = new Chart(document.getElementById('barChart'), {
            type: 'bar',
            data: {
                labels: ['Plain Area', 'Ridge Area', 'Slopy Area', 'Valley Area', 'Hill Slopes'],
                datasets: [{
                    label: '% Block Terrain Area',
                    data: blockTerrain,
                    backgroundColor: '#3498db'
                }, {
                    label: '% MWS Terrain Area',
                    data: mwsTerrain,
                    backgroundColor: '#2ecc71'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title : {
                            display: true,
                            text: 'Percent'
                        }
                    }
                },
                animation: {
                    duration: 0 // Disable animation for better print support
                }
            }
        });

        const lulc_mws_slope = JSON.parse('{{lulc_mws_slope|safe}}')
        const lulc_block_slope = JSON.parse('{{lulc_block_slope|safe}}')

        const lulc_mws_plain = JSON.parse('{{lulc_mws_plain|safe}}')
        const lulc_block_plain = JSON.parse('{{lulc_block_plain|safe}}')
        
        const slopeContainer = document.getElementById('slopeChartContainer');
        const plainContainer = document.getElementById('plainChartContainer');

        if(lulc_mws_slope.some(v => v > 0)){
            const barChart_lulc_slope = new Chart(document.getElementById('barChart-terrain-lulc-slope'), {
                type: 'bar',
                data: {
                    labels: ['Shrubs', 'Barren Areas', 'Trees', 'Farmlands'],
                    datasets: [{
                        label: '% Tehsil Terrain Area under Slope',
                        data: lulc_block_slope,
                        backgroundColor: '#3498db'
                    }, {
                        label: '% MWS Terrain Area under Slope',
                        data: lulc_mws_slope,
                        backgroundColor: '#2ecc71'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title : {
                                display: true,
                                text: 'Percent'
                            }
                        }
                    },
                    animation: {
                        duration: 0 // Disable animation for better print support
                    }
                }
            });
        } else {
            slopeContainer.style.display = 'none';
          }
        

        if(lulc_mws_plain.some(v => v > 0)){
            const barChart_lulc_plain = new Chart(document.getElementById('barChart-terrain-lulc-plain'), {
                type: 'bar',
                data: {
                    labels: ['Shrubs', 'Barren Areas', 'Trees', 'Farmlands'],
                    datasets: [{
                        label: '% Tehsil Terrain Area under Plain',
                        data: lulc_block_plain,
                        backgroundColor: '#3498db'
                    }, {
                        label: '% MWS Terrain Area under Plain',
                        data: lulc_mws_plain,
                        backgroundColor: '#2ecc71'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title : {
                                display: true,
                                text: 'Percent'
                            }
                        }
                    },
                    animation: {
                        duration: 0 // Disable animation for better print support
                    }
                }
            });
        } else {
            plainContainer.style.display = 'none';
          }

        // Waterbody Graphs
        const kharifData = JSON.parse('{{kharif_data|safe}}')
        const rabiData = JSON.parse('{{rabi_data|safe}}')
        const zaidData = JSON.parse('{{zaid_data|safe}}')
        const waterYears = JSON.parse('{{water_years|safe}}')

        const barChart_swb = new Chart(document.getElementById('barChart-swb'), {
        type: 'bar',
        data: {
            labels: waterYears,
            datasets: [
            {
                label: 'Kharif',
                data: kharifData,
                backgroundColor: '#ADD8E6',
                categoryPercentage: 0.6,
                barPercentage: 0.9
            },
            {
                label: 'Kharif-Rabi',
                data: rabiData,
                backgroundColor: '#6495ED',
                categoryPercentage: 0.6,
                barPercentage: 0.9
            },
            {
                label: 'Kharif-Rabi-Zaid',
                data: zaidData,
                backgroundColor: '#0000FF',
                categoryPercentage: 0.6, // optional: tweak spacing
                barPercentage: 0.9
            },
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
            x: {
                stacked: false,
                title: { display: true, text: 'Year' }
            },
            y: {
                stacked: false,
                title: { display: true, text: 'Hectare' }
            }
            },
            animation: { duration: 0 },
            plugins: {
            title: {
                display: true,
                text: 'Surface water availability during Kharif, Rabi, and Zaid (2017-2022)'
            },
            legend: { position: 'top' }
            }
        }
        });
        
        //? Cropping Intensity
        const single = JSON.parse('{{single|safe}}')
        const double = JSON.parse('{{double|safe}}')
        const triple = JSON.parse('{{triple|safe}}')
        const uncrop = JSON.parse('{{uncrop|safe}}')
        const cropYears = JSON.parse('{{crop_years|safe}}')

        const barChart_cropping = new Chart(document.getElementById('barChart-intensity'), {
            type: 'bar',
            data: {
                labels: cropYears, // TODO : Get years from backend, don't hardcode as year would increase as data increase
                datasets: [
                {
                    label: 'Single-Cropping',
                    data: single,
                    backgroundColor: '#57ad2b',

                },
                {
                    label: 'Double-Cropping',
                    data: double,
                    backgroundColor: '#e68600'

                },
                {
                    label: 'Triple-Cropping',
                    data: triple,
                    backgroundColor: '#b3561d'

                },
                {
                    label: 'Uncropped',
                    data: uncrop,
                    backgroundColor: '#A9A9A9'

                },
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x : {
                        stacked : true,
                        title : {
                            display: true,
                            text: 'Year'
                        }
                    },
                    y: {
                        stacked : true,
                        title : {
                            display: true,
                            text: 'Percentage'
                        }
                    }
                },
                animation: {
                    duration: 0 // Disable animation for better print support
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Area under single, double, triple cropping over the years',
                },
            }
        });

        // WaterBalance Graphs and descriptions
        const precipData = JSON.parse('{{precip_data|safe}}')
        const runoffData = JSON.parse('{{runoff_data|safe}}')
        const etData = JSON.parse('{{et_data|safe}}')
        const dgData = JSON.parse('{{dg_data|safe}}')
        const wbYears = JSON.parse('{{wb_years|safe}}')

        const lineChart = new Chart(document.getElementById('lineChart-water'), {
            type: 'bar',
            data: {
                labels: wbYears,
                datasets: [
                {
                    label: 'Runoff',
                    data: runoffData,
                    type: 'line',
                    fill: true,
                    borderColor: '#FF6EF4',
                    backgroundColor: 'rgba(	255, 110, 244, 0.2)',
                    borderWidth: 2,
                    pointRadius: 5,
                    tension: 0.3, // Adds curve to the line
                    order: 0 // Lower order means it's drawn last (in front)
                },{
                    label: 'Precipitation',
                    data: precipData,
                    backgroundColor: '#413ea0',
                    tension: 0.3,
                    fill: false,
                    order: 1
                }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title : {
                            display: true,
                            text: 'Precipitation & Runoff(mm)'
                        }
                    },
                    x : {
                        title : {
                            display: true,
                            text: 'Year'
                        }
                    }
                },
                animation: {
                    duration: 0 // Disable animation for better print support
                }
            }
        });

        const areaChartEvp = new Chart(document.getElementById('lineChart-evp'), {
            type: 'bar',
            data: {
                labels: wbYears,
                datasets: [{
                    label: 'Evapotranspiration',
                    data: etData,
                    type: 'line',
                    fill: true,
                    borderColor: '#90ee90',
                    backgroundColor: 'rgba(	144, 238, 144, 0.2)',
                    borderWidth: 2,
                    pointRadius: 5,
                    tension: 0.3, // Adds curve to the line
                    order: 1 // Lower order means it's drawn last (in front)
                }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title : {
                            display: true,
                            text: 'Evapotranspiration(mm)'
                        }
                    },
                    x : {
                        title : {
                            display: true,
                            text: 'Year'
                        }
                    }
                },
                animation: {
                    duration: 0 // Disable animation for better print support
                }
            }
        });

        const areaChartGW = new Chart(document.getElementById('lineChart-gw'), {
            type: 'bar',
            data: {
                labels: wbYears,
                datasets: [{
                    label: 'Water Balance',
                    data: dgData,
                    type: 'line',
                    fill: true,
                    borderColor: '#a5682a',
                    backgroundColor: 'rgba(	165, 104, 42, 0.2)',
                    borderWidth: 2,
                    pointRadius: 5,
                    tension: 0.3, // Adds curve to the line
                    order: 1 // Lower order means it's drawn last (in front)
                }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title : {
                            display: true,
                            text: 'Water Balance(mm)'
                        }
                    },
                    x : {
                        title : {
                            display: true,
                            text: 'Year'
                        }
                    }
                },
                animation: {
                    duration: 0 // Disable animation for better print support
                }
            }
        });

        // Drought Graphs
        const mod_weeks = JSON.parse('{{mod_drought|safe}}')
        const sev_weeks = JSON.parse('{{sev_drought|safe}}')
        const drysp_all = JSON.parse('{{drysp_all|safe}}')
        const dg_years = JSON.parse('{{dg_years|safe}}')

       const barChart_weeks = new Chart(document.getElementById('Chart-drought-weeks'),{
            type: 'bar',
            data: {
            labels: dg_years,
            datasets: [
                {
                label: 'Moderate Weeks',
                data: mod_weeks,
                backgroundColor: '#EB984E',
                stack: 'ms',           // <-- stack group A (Moderate+Severe)
                },
                {
                label: 'Severe Weeks',
                data: sev_weeks,
                backgroundColor: '#E74C3C',
                stack: 'ms',           // <-- same stack as Moderate
                },
                {
                label: 'Dryspell Weeks',
                data: drysp_all,
                backgroundColor: '#8884d8',
                stack: 'dry',          // <-- separate stack = separate bar
                },
            ],
            },
            options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { stacked: true },    // allow multiple stacks side-by-side
                y: { stacked: true,      // stack within each stack group
                    title: { display: true, text: 'No. of Weeks' } },
            },
            animation: { duration: 0 },
            plugins: {
                title: { display: true, text: 'Drought Data over the years' },
                legend: { display: true },
            },
            },
        }
        );


        //Village Profile section
        const villageNames = JSON.parse('{{ villages_name|safe }}')
        var ulElement = document.getElementById("village-names");

        if(villageNames.length === 0){
            const section = document.querySelector('.village-section');
            if (section) section.style.display = 'none';
        }

        const swc_works = JSON.parse('{{ swc_works|safe }}')
        const lr_works = JSON.parse('{{ lr_works|safe }}')
        const plantation_work = JSON.parse('{{ plantation_work|safe }}')
        const iof_works = JSON.parse('{{ iof_works|safe }}')
        const ofl_works = JSON.parse('{{ ofl_works|safe }}')
        const ca_works = JSON.parse('{{ ca_works|safe }}')
        const ofw_works = JSON.parse('{{ ofw_works|safe }}')

        const sc_pop = JSON.parse('{{ villages_sc|safe }}')
        const st_pop = JSON.parse('{{ villages_st|safe }}')
        const tot_pop = JSON.parse('{{ villages_pop|safe }}')

        // Iterate and append villages as list items
        villageNames.forEach(function(village) {
            var li = document.createElement("li");
            li.textContent = village;
            ulElement.appendChild(li);
        });

        var tableBody = document.querySelector("#village-table tbody");

        villageNames.map((item, idx) => {
            var row = document.createElement("tr");

            row.innerHTML = `
                <td>${item}</td>
                <td>${tot_pop[idx]}</td>
                <td>${sc_pop[idx]}</td>
                <td>${st_pop[idx]}</td>
                <td>${swc_works[idx]}</td>
                <td>${lr_works[idx]}</td>
                <td>${plantation_work[idx]}</td>
                <td>${iof_works[idx]}</td>
                <td>${ofw_works[idx]}</td>
                <td>${ofl_works[idx]}</td>
                <td>${ca_works[idx]}</td>
            `;

            tableBody.appendChild(row);
        })

        //Setting the Date Time of Report being saved or printed
        const currentDate = new Date();

        // Format the date as "Month Day, Year" (e.g., "March 3, 2025")
        const formattedDate = currentDate.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });

        // Insert the formatted date into the span
        document.getElementById("report-date").textContent = formattedDate;

        function printReport() {
            // Trigger browser print dialog
            window.print();
        }

        // Add print-specific preparation
        window.addEventListener('beforeprint', function() {
            // Force render maps to their current view

            // Force render all charts
            barChart.render();
            lineChart.render();
            pieChart.render();
        });
        

        // Handle post-print adjustments
        window.addEventListener('afterprint', function() {
            // Re-render maps with proper size
            setTimeout(function() {
                mainMap.updateSize();
            }, 500);
        });

        (function () {
            // layers we want to wait on
            const layersToWatch = [
                /* tile */
                baseLayer,
                /* image/WMS */
                wmsLayer, degradRaster, lulcRaster, treeReduceRaster, urbanRaster
            ].filter(Boolean);

            let pending = 0;
            let resolveReady;
            const readyPromise = new Promise(res => (resolveReady = res));

            function hookSource(src) {
                // Works for Tile sources
                if (src && src.on) {
                src.on('tileloadstart', () => pending++);
                src.on(['tileloadend','tileloaderror'], () => { pending = Math.max(0, pending - 1); check(); });
                // Works for ImageWMS
                src.on('imageloadstart', () => pending++);
                src.on(['imageloadend','imageloaderror'], () => { pending = Math.max(0, pending - 1); check(); });
                }
            }

            layersToWatch.forEach(l => hookSource(l.getSource && l.getSource()));
            
            // consider SWB vector overlay too (not critical for basemap):
            // hookSource(vectorLayer.getSource()); // if you want to block on this as well

            let renderedOnce = false;
            function afterRender() {
                renderedOnce = true;
                check();
            }

            // when any map renders, note it
            [mainMap, TerrainMap, DegradMap, lulcMap, treeReduceMap, urbanMap,
            ComparisonMap1, ComparisonMap2, ComparisonMap3, ComparisonMap4, ComparisonMap5, swbMap]
            .filter(Boolean)
            .forEach(m => m.once('rendercomplete', afterRender));

            // Charts: flip a flag when you finish constructing them
            window.__chartsReady = true; // you already set animation: {duration: 0}, so theyâ€™re instant

            let settleTimer;
            function check() {
                // resolve only when nothing is loading, at least one render happened, and charts are done
                if (pending === 0 && renderedOnce && window.__chartsReady) {
                // give the browser a breath to paint the final frame
                clearTimeout(settleTimer);
                settleTimer = setTimeout(() => {
                    try {
                    [mainMap, TerrainMap, DegradMap, lulcMap, treeReduceMap, urbanMap,
                    ComparisonMap1, ComparisonMap2, ComparisonMap3, ComparisonMap4, ComparisonMap5, swbMap]
                    .filter(Boolean)
                    .forEach(m => m.renderSync());
                    } catch(e) {}
                    window.__mapsReady = true;
                    resolveReady(true);
                }, 300);
                }
            }

            // expose a promise Selenium can await if you prefer execute_async_script
            window.__mapsReadyPromise = readyPromise;

            // kick the check once in case nothing loads (rare)
            setTimeout(check, 0);
        })();

    </script>
</body>
</html>