import csv
import os
import time

from celery import shared_task
import pandas as pd

from computing.utils import sync_project_fc_to_geoserver, calculate_precipitation_season
from computing.water_rejuvenation.water_rejuventation import get_lulc_class, find_closest_water_pixel, \
    find_watersheds_for_point_with_buffer
from nrm_app.settings import PAN_INDIA_LULC_PATH
from projects.models import Project
from projects.serializers import ProjectSerializer
from utilities.constants import SITE_DATA_PATH, GEE_PATHS
from utilities.gee_utils import (
    ee_initialize,
    get_distance_between_two_lan_long, get_gee_asset_path, check_task_status, gdf_to_ee_fc, get_gee_dir_path
)
import ee
import logging
from datetime import  datetime
import geemap


logger = logging.getLogger(__name__)

from waterrejuvenation.utils import get_filtered_mws_layer_name, gen_proj_roi, wait_for_task_completion, \
    get_waterbody_id_for_lat_long, WATER_REJ_GEE_ASSET, clip_lulc_output, delete_asset_on_GEE, find_nearest_water_pixel
from computing.surface_water_bodies.swb import generate_swb_layer
from computing.mws.precipitation import  precipitation
from shapely.geometry import Point
import geopandas as gpd
from computing.drought.drought import calculate_drought

@shared_task
def Upload_Desilting_Points(file_obj_id):
    from .models import WaterbodiesFileUploadLog, WaterbodiesDesiltingLog
    ee_initialize()
    merged_features = []

    #Initialize objects for given parameters
    wb_obj = WaterbodiesFileUploadLog.objects.get(pk = file_obj_id)
    proj_obj = Project.objects.get(pk=wb_obj.project_id)

    # Generating mws layer name
    mws_asset_id = get_filtered_mws_layer_name(proj_obj.name, 'filtered_mws')

    #Since we wanted to build all the layer new everytime some one upload We are deleting asset first
    # delete_asset_on_GEE(mws_asset_id)

    if wb_obj.process:
        logger.warning("file already processed. Skipping and not processing")
    else:
        filepath = wb_obj.file
        df = pd.read_excel(filepath)
        for index, row in df.iterrows():
             dsilting_obj_log = WaterbodiesDesiltingLog(**{
                'name_of_ngo': row['Name of NGO'],
                'State': row['State'],
                'District': row['District'],
                'Taluka': row['Taluka'],
                'Village': row['Village'],
                'waterbody_name': row['Name of the waterbody '],
                'lat': row['Latitude'],
                'lon': row['Longitude'],
                'slit_excavated': row['Silt Excavated as per App'],
                'excel_hash': wb_obj.excel_hash,
                'project': proj_obj
             })

             #get lulc class on given lat long
             lulc_class = get_lulc_class(dsilting_obj_log.lat, dsilting_obj_log.lon)

             #Figure out closet waterbody pixel
             result_dict= find_nearest_water_pixel(dsilting_obj_log.lat, dsilting_obj_log.lon,  1500)
             status, closest_lat, closest_lon, distance = result_dict['success'], result_dict['latitude'], result_dict['longitude'], result_dict['distance_m']
             logger.info(f"Desilting points generated by algo: lat={closest_lat}, lon={closest_lon}")

             #todos :  Add a filed in desilting log to detect for any particular lat long alog is not able to find closest waterbody pixel for furture analysis
             if closest_lat and closest_lat:
                if status:
                     dsilting_obj_log.closest_wb_lat  = closest_lat
                     dsilting_obj_log.closest_wb_long = closest_lon
                     dsilting_obj_log.distance_closest_wb_pixel = distance
                     dsilting_obj_log.process = True
                     dsilting_obj_log.save()
                     watershed_fc, buffer = find_watersheds_for_point_with_buffer(closest_lat, closest_lon)
                     merged_features.append(watershed_fc)

        intersecting_mws_asset = ee.FeatureCollection(merged_features).flatten()
        filter_mws_task = ee.batch.Export.table.toAsset(
                 collection=intersecting_mws_asset,
                 description='water_rej_app_mws_tasks',
                 assetId=mws_asset_id
             )
        try:
            filter_mws_task.start()
            logger.info("MWS task started for given lat long")
            wait_for_task_completion(filter_mws_task)
            logger.info("MWS task completed")
            clip_lulc_output(mws_asset_id, proj_obj.id)
            logger.info("luc Task finished for lulc")
        except Exception as e:
            logger.error(f"Error in Generating Lulc and mws layer: {str(e)}")

    roi = gen_proj_roi(proj_obj.name)
    logger.info("Generating SWB layer for given lat long")

    asset_suffix_lulc = 'clipped_lulc_filtered_mws_' + str(proj_obj.name.lower())
    asset_folder_lulc = [str(proj_obj.name)]
    result = generate_swb_layer.delay(roi_path=mws_asset_id, asset_suffix=asset_suffix_lulc, asset_folder_list=asset_folder_lulc\
                                       ,app_type = "WATER_REJ", start_year = '2017', end_year = '2023')
    result_task = result.get()
    print ("asset id")
    logger.info("SWB layer Generation successfull")
    mapping_result = get_waterbody_id_for_lat_long(wb_obj.excel_hash, result_task['swb_asset_id'])
    desilting_layer_task = BuildDesiltingLayer.delay(proj_obj.id)
    logger.info("Desilting point layer is generated")
    result = desilting_layer_task.get()
    logger.info(result)
    geoserver_layer_name='WaterRejapp-'+str(proj_obj.name)+'_'+str(proj_obj.id)
    result_geojson = BuildGeojson.delay(result_task['swb_asset_id'], result, geoserver_layer_name, proj_obj.name)
    logger.info("layer generaetd and pushed to geoserver")
    mws_roi = ee.FeatureCollection(mws_asset_id)
    asset_suffix_prec = 'clipped_precipitation_filtered_mws_' + str(proj_obj.name.lower())
    asset_folder_prec = [str(proj_obj.name)]
    # # precipitation(roi=mws_roi, asset_suffix=asset_suffix_prec, asset_folder_list=asset_folder_prec, app_type="WATER_REJ", start_date='2017-07-01', end_date = '2024-06-30')
    asset_suffix_draught = 'clipped_lulc_filtered_mws_' + str(proj_obj.name.lower())
    print("running draught")
    result_d = calculate_drought.delay(roi_path=mws_asset_id, asset_suffix = asset_suffix_draught, asset_folder_list = asset_folder_prec, app_type="WATER_REJ",start_year=2017, end_year = 2022)
    result_op = result_d.get()
    print ("generated")
    dst_filename = (
            "drought_"
            + asset_suffix_draught
            + "_"
            + str('2017')
            + "_"
            + str('2022')
    )
    description = "Prec_fortnight_" + asset_suffix_prec
    asset_id_prec = (
            get_gee_dir_path(
                asset_folder_prec, asset_path=GEE_PATHS["WATER_REJ"]["GEE_ASSET_PATH"]
            )
            + description
    )

    mws = ee.FeatureCollection(mws_asset_id)
    precip = ee.FeatureCollection(asset_id_prec)
    join = ee.Join.inner()

    # Define filters for the join (match 'uuid')
    filter = ee.Filter.equals(leftField='uid', rightField='uid')

    # Apply the join
    joined = join.apply(mws, precip, filter)

    # Merge the features from both collections
    def merge_features(feature):
        primary = ee.Feature(feature.get('primary'))
        secondary = ee.Feature(feature.get('secondary'))
        return primary.copyProperties(secondary)  # Copy all properties from precip into mws feature

    # Map the merged features
    layer_name = 'WaterRejapp_mws_' + str(proj_obj.name) + '_' + str(proj_obj.id)
    joined_fc = ee.FeatureCollection(joined.map(merge_features))
    gdf = geemap.ee_to_gdf(joined_fc)
    mws_geojson_op = 'data/fc_to_shape/'+str(proj_obj.name)+"/"+layer_name
    gdf.to_file(mws_geojson_op, driver='GeoJSON')
    season_fc = calculate_precipitation_season(mws_geojson_op)
    sync_project_fc_to_geoserver(season_fc, proj_obj.name, layer_name, 'waterrej')


@shared_task()
def BuildDesiltingLayer(project_id):
    ee_initialize()
    from .models import WaterbodiesDesiltingLog
    instance = Project.objects.get(pk=project_id)
    data = WaterbodiesDesiltingLog.objects.filter(project_id=project_id, closest_wb_lat__isnull=False)

    asset_id = WATER_REJ_GEE_ASSET + str(instance.name.lower()) + "/" + 'Closest_point_to_Desilting_' + str(instance.app_type)
    delete_asset_on_GEE(asset_id)
    project_id = instance.id
    org_name = instance.organization.name
    app_type = instance.app_type
    project_name = instance.name
    filename = f"{org_name}_{app_type}_{project_id}_{project_name}_{int(datetime.now().timestamp())}"+".csv"
    directory = f"{org_name}/{app_type}/{project_id}_{project_name}"
    full_path = os.path.join(SITE_DATA_PATH, directory)
    file_path = full_path + filename
    os.makedirs(full_path, exist_ok=True)
    with open(file_path, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['latitude', 'longitude', 'desiltingpoint_lat', 'desiltingpoint_lon', 'name_of_ngo', 'State', 'District', 'Taluka', 'village', 'waterbody_name', 'slit_excavated'])
        for loc in data:
            writer.writerow([loc.closest_wb_lat, loc.closest_wb_long,loc.lat, loc.lon, loc.name_of_ngo, loc.State, loc.District, loc.Taluka, loc.Village, loc.waterbody_name, loc.slit_excavated])
    df = pd.read_csv(file_path)
    geometry = [Point(xy) for xy in zip(df['longitude'], df['latitude'])]
    gdf = gpd.GeoDataFrame(df, geometry=geometry)
    gdf.set_crs("EPSG:4326", allow_override=True, inplace=True)
    gdf = gdf.dropna(subset=['geometry'])
    fc = gdf_to_ee_fc(gdf)
    point_tasks = ee.batch.Export.table.toAsset(
        collection=fc,
        description='water_rej_desilting_point_tasks',
        assetId=asset_id
    )
    point_tasks.start()
    wait_for_task_completion(point_tasks)
    return asset_id

@shared_task()
def BuildGeojson(swb2_asset, desilting_point_asset, layer_name, project_name):
    ee_initialize()
    # Load the FeatureCollections and Image
    waterbodies = ee.FeatureCollection(swb2_asset)  # Replace with your actual table2 asset
    desiltingPoints = ee.FeatureCollection(desilting_point_asset)  # Replace with your actual table asset

    # Map over waterbodies to attach intersecting point geometry and properties
    def attach_matching_point(feature):
        # Filter points that intersect (fall inside) the polygon
        contained_points = desiltingPoints.filterBounds(feature.geometry())

        # Get the first matching point (optional: you can use reduceToCollection or something else if needed)
        point = contained_points.first()

        # Check if any point was found
        return ee.Algorithms.If(
            point,
            ee.Feature(feature).copyProperties(point).set('matched', True),
            feature.set('matched', False)
        )

    # Apply the function to each waterbody polygon
    joined = waterbodies.map(attach_matching_point)
    matched_polygons = ee.FeatureCollection(joined).filter(ee.Filter.eq('matched', True))

    # Filter for polygons that had matches


    # Export the result


    sync_project_fc_to_geoserver(matched_polygons, project_name, layer_name, 'waterrej')
    return  {'Sucess':True}













