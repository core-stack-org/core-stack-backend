import csv
import os
import time

from celery import shared_task
import pandas as pd

from computing.utils import sync_project_fc_to_geoserver
from computing.water_rejuvenation.water_rejuventation import get_lulc_class, find_closest_water_pixel, \
    find_watersheds_for_point_with_buffer
from nrm_app.settings import PAN_INDIA_LULC_PATH
from projects.models import Project
from projects.serializers import ProjectSerializer
from utilities.constants import SITE_DATA_PATH
from utilities.gee_utils import (
    ee_initialize,
    get_distance_between_two_lan_long, get_gee_asset_path, check_task_status, gdf_to_ee_fc
)
import ee
import logging
from datetime import  datetime

logger = logging.getLogger(__name__)

from waterrejuvenation.utils import get_filtered_mws_layer_name, gen_proj_roi, wait_for_task_completion, \
    get_waterbody_id_for_lat_long, WATER_REJ_GEE_ASSET, clip_lulc_output, delete_asset_on_GEE
from computing.surface_water_bodies.swb1 import generate_swb_layer
from shapely.geometry import Point
import geopandas as gpd

@shared_task
def Upload_Desilting_Points(file_obj_id):
    from .models import WaterbodiesFileUploadLog, WaterbodiesDesiltingLog
    ee_initialize()
    merged_features = []
    #Initialize objects for given parameters
    wb_obj = WaterbodiesFileUploadLog.objects.get(pk = file_obj_id)
    proj_obj = Project.objects.get(pk=wb_obj.project_id)

    # Generating mws layer name
    mws_asset_id = get_filtered_mws_layer_name(proj_obj.name, 'filtered_mws')

    #Since we wanted to build all the layer new everytime some one upload We are deleting asset first
    delete_asset_on_GEE(mws_asset_id)

    if wb_obj.process:
        logger.warning("file already processed. Skipping and not processing")
    else:
        filepath = wb_obj.file
        df = pd.read_excel(filepath)
        for index, row in df.iterrows():
             dsilting_obj_log = WaterbodiesDesiltingLog(**{
                'name_of_ngo': row['Name of NGO'],
                'State': row['State'],
                'District': row['District'],
                'Taluka': row['Taluka'],
                'Village': row['Village'],
                'waterbody_name': row['Name of the waterbody '],
                'lat': row['Latitude'],
                'lon': row['Longitude'],
                'slit_excavated': row['Silt Excavated as per App'],
                'excel_hash': wb_obj.excel_hash,
                'project': proj_obj
             })

             #get lulc class on given lat long
             lulc_class = get_lulc_class(dsilting_obj_log.lat, dsilting_obj_log.lon)

             #Figure out closet waterbody pixel
             success, close_lat, close_lon, distance = find_closest_water_pixel(dsilting_obj_log.lon, dsilting_obj_log.lat, lulc_class)

             logger.info(f"Desilting points generated by algo: lat={close_lat}, lon={close_lon}")

             #todos :  Add a filed in desilting log to detect for any particular lat long alog is not able to find closest waterbody pixel for furture analysis
             if close_lat and close_lon:
                if success:
                     dsilting_obj_log.closest_wb_lat  = close_lat
                     dsilting_obj_log.closest_wb_long = close_lon
                     dsilting_obj_log.distance_closest_wb_pixel = distance
                     dsilting_obj_log.process = True
                     dsilting_obj_log.save()
                     watershed_fc, buffer = find_watersheds_for_point_with_buffer(close_lat, close_lon)
                     merged_features.append(watershed_fc)

        intersecting_mws_asset = ee.FeatureCollection(merged_features).flatten()
        filter_mws_task = ee.batch.Export.table.toAsset(
                 collection=intersecting_mws_asset,
                 description='water_rej_app_mws_tasks',
                 assetId=mws_asset_id
             )
        try:
            filter_mws_task.start()
            logger.info("MWS task started for given lat long")
            wait_for_task_completion(filter_mws_task)
            logger.info("MWS task completed")
            clip_lulc_output(mws_asset_id, proj_obj.id)
            logger.info("luc Task finished for lulc")
        except Exception as e:
            logger.error(f"Error in Generating Lulc and mws layer: {str(e)}")

    roi = gen_proj_roi(proj_obj.name)
    logger.info("Generating SWB layer for given lat long")
    result =  generate_swb_layer.delay('2017', '2023', roi=roi, app_name="waterrej_app", proj_name=proj_obj.name, force_regenerate=True)
    swb_asset_id = result.get()
    logger.info("SWB layer Generation successfull")
    mapping_result = get_waterbody_id_for_lat_long(wb_obj.excel_hash, swb_asset_id)
    desilting_layer_task = BuildDesiltingLayer.delay(proj_obj.id)
    logger.info("Desilting point layer is generated")
    result = desilting_layer_task.get()


    BuildGeojson.delay(swb_asset_id, result, geoserver_layer_name)
    logger.info("layer generaetd and pushed to geoserver")


@shared_task()
def BuildDesiltingLayer(project_id):
    ee_initialize()
    from .models import WaterbodiesDesiltingLog
    instance = Project.objects.get(pk=project_id)
    data = WaterbodiesDesiltingLog.objects.filter(project_id=project_id, closest_wb_lat__isnull=False)

    asset_id = WATER_REJ_GEE_ASSET + str(instance.name) + "/" + 'Closest_point_to_Desilting_' + str(instance.app_type)
    delete_asset_on_GEE(asset_id)
    project_id = instance.id
    org_name = instance.organization.name
    app_type = instance.app_type
    project_name = instance.name
    filename = f"{org_name}_{app_type}_{project_id}_{project_name}_{int(datetime.now().timestamp())}"+".csv"
    directory = f"{org_name}/{app_type}/{project_id}_{project_name}"
    full_path = os.path.join(SITE_DATA_PATH, directory)
    file_path = full_path + filename
    os.makedirs(full_path, exist_ok=True)
    with open(file_path, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['latitude', 'longitude', 'desiltingpoint_lat', 'desiltingpoint_lon', 'name_of_ngo', 'State', 'District', 'Taluka', 'village', 'waterbody_name', 'slit_excavated'])
        for loc in data:
            writer.writerow([loc.closest_wb_lat, loc.closest_wb_long,loc.lat, loc.lon, loc.name_of_ngo, loc.State, loc.District, loc.Taluka, loc.Village, loc.waterbody_name, loc.slit_excavated])
    df = pd.read_csv(file_path)
    geometry = [Point(xy) for xy in zip(df['longitude'], df['latitude'])]
    gdf = gpd.GeoDataFrame(df, geometry=geometry)
    gdf.set_crs("EPSG:4326", allow_override=True, inplace=True)
    gdf = gdf.dropna(subset=['geometry'])
    fc = gdf_to_ee_fc(gdf)
    point_tasks = ee.batch.Export.table.toAsset(
        collection=fc,
        description='water_rej_desilting_point_tasks',
        assetId=asset_id
    )
    point_tasks.start()
    wait_for_task_completion(point_tasks)
    return asset_id

@shared_task()
def BuildGeojson(swb2_asset, desilting_point_asset, layer_name):
    ee_initialize()
    # Load the FeatureCollections and Image
    waterbodies = ee.FeatureCollection(swb2_asset)  # Replace with your actual table2 asset
    desiltingPoints = ee.FeatureCollection(desilting_point_asset)  # Replace with your actual table asset

    # Map over waterbodies to attach intersecting point geometry and properties
    def attach_matching_point(feature):
        # Filter points that intersect (fall inside) the polygon
        contained_points = desiltingPoints.filterBounds(feature.geometry())

        # Get the first matching point (optional: you can use reduceToCollection or something else if needed)
        point = contained_points.first()

        # Check if any point was found
        return ee.Algorithms.If(
            point,
            ee.Feature(feature).copyProperties(point).set('matched', True),
            feature.set('matched', False)
        )

    # Apply the function to each waterbody polygon
    joined = waterbodies.map(attach_matching_point)
    matched_polygons = ee.FeatureCollection(joined).filter(ee.Filter.eq('matched', True))

    # Filter for polygons that had matches

    print (layer_name)
    # Export the result


    sync_project_fc_to_geoserver(matched_polygons, layer_name, 'waterrej', 5)














